'''
Challenge for 27/Abr/2020

Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:

Only one letter can be changed at a time
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
Note:

Return an empty list if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.
Example 1:
Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output:
 ["hit","hot","dot","dog","cog"],
  ["hit","hot","lot","log","cog"]


Example 2:
Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: []
(The endWord "cog" is not in wordList, therefore no possible transformation)

[source: leetcode.com, wordladder2]
'''

def adjacency_matrix_maker(vertices_list):
    dimension = len(vertices_list)

    #Initialize matrix according to dimensions
    adj_matrix = [] 
    for row in range(dimension):
        adj_matrix.append([])

    #Edge weights calculation and matrix insertion.
    for row in range(dimension):
        for col in range(dimension):
            adj_matrix[row].append(measure_edge_weight(vertices_list[row],vertices_list[col]))
            
    return adj_matrix



def measure_edge_weight(starting_point, next_point): #Based on Hamming distance
    distance = 0
    
    #Hamming distance rule
    comparison_vector = list(zip(starting_point,next_point)) #Maps each character from each word and zips to compare.
    for character_pair in comparison_vector:
        if character_pair[0] != character_pair[1]:
            distance += 1
            
    if distance != 1: #No vertex can return to itself, or can reach a vertex that requires
                    #a replacement of more than 1 letter.
        distance = float('inf')
        
    return distance



def dijkstra(vertices_list, adjacency_matrix, source_vertex, target_vertex):    
    
    try:
        #Gets indexes for easier handling
        source_vertex = vertices_list.index(source_vertex)
        target_vertex = vertices_list.index(target_vertex)
        vertices_list = [index for index in range(len(vertices_list))]

        
        visited,unvisited = [],vertices_list.copy() #Create visited vertices array and unvisited vertices queue. All vertices are unvisited in the beginning.
        #Creates a column that stores the shortest total distance to each vertex from the source_vertex:        
        min_total_distance = [0 if vertex==source_vertex else float('inf') for vertex in vertices_list] #Initializes distance to source vertex as 0, and everything else as infinite.

        previous = [list() for vertex in vertices_list] #Creates a column that stores a list of previous vertices for each vertex.

        '''
        Imagine a table composed by column arrays vertices_list, min_total_distance and previous. That's how information will be stored.

        Dijsktra algorithm follows this logic:
            While there are unvisited vertices:
                Get an unvisited vertex with the shortest total distance
                Set that vertex as current vertex
                Explore neighbor vertices and calculate the shortest total distance for each one, taking into account you travel through the current vertex.
                If for a certain neighbor vertex the calculated shortest total distance is lower than the currently known shortest total distance for the same neighbor vertex, then:
                    Update the shortest total distance for that neighbor vertex with the one you calculated
                    Store the current vertex as a predecessor of that neighbor vertex
                Mark current vertex as visited
                Pop current vertex from visited.
        '''
        
            
        while unvisited: #While there are unvisited vertices

            ###Distance calculations:
            
            # All this is necessary because there may be situations when the currently known shortest total distances belongs to a vertex already visited, so we need to ignore that vertex.
            known_total_dist_unvisited = [min_total_distance[vertex] for vertex in unvisited] #Gets the currently known shortest total distances for every unvisited vertex
            current = unvisited[known_total_dist_unvisited.index(min(known_total_dist_unvisited))] #Always gets the unvisited vertex with minimum currently known shortest total distance 
                                                                                                    #and sets it as the current vertex. This is the priority of the visited queue.
            '''
            What if more than 1 unvisited vertex got the same minimum currently known shortest total distance? Will it be ignored?
            The algorithm takes that into account, don't worry... 
            '''
            #Calculation of shortest total distance through current vertex:
            #Loads the row of the adjacency matrix belonging to the current vertex (that means all adjacencies from the current vertex)
            #We sum the shortest total distance to the current vertex and the travel distance (edge weight) to reach the next vertices from the current vertex.
            #This is the updated distance to neighbors.
            upd_neighbor_dist = [adjacency_matrix[current][vertex] + min_total_distance[current] \
                                  if vertex not in visited else float('inf') for vertex in vertices_list] #The condition sets the travel distance to infinite for neighbor vertices 
                                                                                                          #already visited so we don't return to them. 
            
            ###Distance comparisons:
            
            #The next condition check is important: If all your updated shortest distances to neighbors are infinite, it means you reached the current vertex but now we have nowhere to go.
            if all(distance == float('inf') for distance in upd_neighbor_dist):       
                unvisited.remove(current) #Remove the current vertex from the unvisited queue.
                visited.append(current) #Mark current vertex as visited.
                break #End the while cycle and evaluate why do we have nowhere to go: Did we reached all the vertices in the graph or there is no possible way to reach the target vertex?
                '''
                Some scenarios where the latter may happen is when there are no nodes connecting the source and target vertices, such as:
                    A ðŸ¡’ B   C ðŸ¡’ F   G ðŸ¡’ E â†’ F
                There's simply no way to reach F from A, because there's no connection from neighboring vertex B to the others that lead to F.
                '''        
            else: #If there's at least one update shortest distance to neighbors is finite then we have somewhere to go:
                for neighbor_vertex in unvisited: #Explore each neighbor vertex that has not been visited:
                    #Checks if the distance to reach a certain neighbor from the source vertex and through the current vertex is less than the total distance we currently known.
                    #If true, that means that there's a shorter path to reach this neighbor vertex than the one we previously considered.
                    #As we started all the currently known total distances as infinite, most of the comparisons will be finite to infinite and the following will execute:
                    if upd_neighbor_dist[neighbor_vertex] < min_total_distance[neighbor_vertex]:
                        min_total_distance[neighbor_vertex] = upd_neighbor_dist[neighbor_vertex] #Updates the shortest total distance from source vertex to that neighbor vertex
                                                                                                #with the shorter path distance
                        previous[neighbor_vertex].append(current) #As we found a shorter path to the neighbor vertex through the current vertex,
                                                                #that means the current vertex is a predecessor to that neighbor and we store it as such.
                        '''
                        Why an append() method? Because there may be graphs where a vertex can be reached from 2 previous vertices with identical total travel distance:
                        For example: A ðŸ¡’ B   C ðŸ¡’ B 
                        If each edge has a cost of 1, then B can be reached from A or C with the same total cost, so previous[B]= [A, C]
                        There may even be scenarios where there are multiple shortest paths to the target vertex with identical total distance.
                        '''

                    #Remember the question about What if more than 1 unvisited vertex got the same minimum currently known shortest total distance? This takes care of it.
                    #Checks if the distance to reach a certain neighbor from the source vertex and through the current vertex is equal than the total distance we currently known.
                    #If true, that means that there's an alternative path just as short to reach this neighbor vertex in addition to the one we have been considering.
                    elif upd_neighbor_dist[neighbor_vertex] == min_total_distance[neighbor_vertex]\
                         and upd_neighbor_dist[neighbor_vertex] != float('Inf'): #This makes sure the algorithm ignores comparisons of the infinite=infinite kind,
                                                                                 #thus ensuring you only backtrack/ramify to an alternative path when there are connecting vertices.
                        min_total_distance[neighbor_vertex] = upd_neighbor_dist[neighbor_vertex] #Updates the shortest total distance from source vertex to that neighbor vertex
                                                                                                #with the shorter path distance
                        previous[neighbor_vertex].append(current) #As we found another equally short path to the neighbor vertex through the current vertex,
                                                                #that means the current vertex is also a predecessor to that neighbor and we store it as such.               


            ##All the neighboring vertices has been explored, so the current vertex is marked as visited and the unvisited queue and the visited array are updated accordingly:
            unvisited.remove(current) 
            visited.append(current)

        #When all the updated shortest distances to neighbors are infinite, it means we have nowhere to go. But why?
        
        if target_vertex in visited: #We reached all the vertices in the graph
            #The predecessors may form a graph: Let's search and retrieve them in order.
            return retrieval(previous, target_vertex)
            print(visited, unvisited, target_vertex) 
        else: #There is no possible way to reach the target vertex
            return 'Target word cannot be reached.' 
    
    except:
        return 'No shortest path exists.' #If the target word is not in the word list.



def retrieval(predecessor, target_vertex):
    
    def word_list_translator(paths):
        #This function translates vertices' indexes to the words included in the word list.
        for path in paths:
            for index,vertex in enumerate(path):
                path[index] = word_list[vertex]
        return paths

    #We start from the end and backtrack.
    paths = [[target_vertex]] #Initialized as an array of arrays, just in case there are multiple predecessors somewhere along the graph and branching out becomes necessary...
    alternatives = 0

    #The following is a Breadth-First-Search with a twist
    while alternatives < len(paths): #Do while there are still paths to explore.
        
        next_pred = predecessor[paths[alternatives][-1]] #Get the next predecessor in the last position of THIS path array we're travesing.
        #As we're backtracking, the last position means being closer to the source vertex.
        
        while next_pred != None: #If there are no next predecessors, then we reached the source node.
            '''
            We don't search in another path until we reach the source node in the current path, that's why the above while condition is there
            '''
            next_pred = predecessor[paths[alternatives][-1]]
            
            if len(next_pred) == 1:#If there's single next predecessor, retrieve it and append it to THIS path array.
                next_pred = next_pred[0]
                paths[alternatives].append(next_pred)
            
            elif len(next_pred)>1: #The twist: If there are multiple next predecessors, there will be several shortest paths.
                alternate_paths = [] #Initialize alternate paths. This will become an array of arrays to store several paths.
                temp_path = paths[alternatives].copy() #Copy all the predecessors reached until this point and assign it to a temporal array.
                
                for previous_vertex in next_pred: #For every next predecessor of the group of multiple next predecessors:
                    temp_path.append(previous_vertex) #Add a predecessor to the temporal array, thus forming an alternate path
                    alternate_paths.append(temp_path) #Add the alternate path to the list of alternate paths.
                    temp_path = paths[alternatives].copy() #Turn back the temporal array to the divergence point, so you can create more alternate paths
                    paths = alternate_paths #Update the paths with all the alternate paths found.
            else:
                break #If there are no next predecessors, then we reached the source node and we're done with THIS path.

        paths[alternatives].reverse() #We were backtracking THIS path, now we switch the order to read from source to end.
        alternatives += 1 #Update how many paths we have sought.

    paths=word_list_translator(paths) #Translate vertices' indexes to the words included in the word list, so a human can read them.
    
    return paths


    
#For the sake of simplicity, preset data. Getting input is trivial.    
word_list= ["hot","dot","dog","lot","log","cog"]
begin_word = 'hit'
end_word = 'cog'

if begin_word not in word_list:
    word_list.append(begin_word)

solution=dijkstra(word_list,adjacency_matrix_maker(word_list),begin_word,end_word)
print(solution)
